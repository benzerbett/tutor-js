// Generated by CoffeeScript 2.3.2
let get;

get = require('lodash/get');

jasmine.addMatchers({
  toHaveRendered: function() {
    return {
      compare: function(wrapper, selector) {
        let matchCount, result;
        matchCount = wrapper.find(selector).length;
        result = {
          pass: matchCount === 1,
        };
        if (result.pass) {
          result.message = function() {
            return `${selector} was found`;
          };
        } else {
          result.message = function() {
            return `Expected wrapper to contain \`${selector}\` only once, but it was found ${matchCount} times`;
          };
        }
        return result;
      },
    };
  },
});

expect.extend({
  toHaveChanged: function(fn, tests) {
    let expected, failures, i, j, k, len, len1, test, testValue, utils;
    failures = [];
    utils = this.utils;
    testValue = function(i, test, type, expected) {
      let actual, hint, name, pass;
      actual = get(test.object, test.property, typeof test.value === 'function' ? test.value() : void 0);
      if (typeof actual !== 'number') {
        actual = parseFloat(actual);
      }
      if (test.precision) {
        utils.ensureNumbers(actual, expected, `test index ${i}`);
        pass = Math.abs(expected - actual) < Math.pow(10, -test.precision) / 2;
        hint = utils.matcherHint('.toBeCloseTo');
      } else {
        pass = expected === actual;
        hint = utils.matcherHint('.toEqual');
      }
      name = test.property || i;
      if (!pass) {
        return failures.push(`${name}: ${type} ${hint}: ${utils.printExpected(expected)}, received ${utils.printReceived(actual)}`);
      }
    };
    for (i = j = 0, len = tests.length; j < len; i = ++j) {
      test = tests[i];
      testValue(i, test, 'from value', test.from);
    }
    fn();
    for (i = k = 0, len1 = tests.length; k < len1; i = ++k) {
      test = tests[i];
      expected = test.by != null ? test.from + test.by : test.to;
      testValue(i, test, 'changed value', expected);
    }
    if (failures.length) {
      return {
        pass: false,

        message: function() {
          return failures.join('\n');
        },
      };
    } else {
      return {
        pass: true,

        message: function() {
          return 'all matched';
        },
      };
    }
  },
});
